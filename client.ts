//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class Client {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * (Auth)
     * @return OK
     */
    productCategoriesAll(): Promise<ListProductCategoryResponse[]> {
        let url_ = this.baseUrl + "/api/v1/product-categories";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProductCategoriesAll(_response);
        });
    }

    protected processProductCategoriesAll(response: Response): Promise<ListProductCategoryResponse[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ListProductCategoryResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ListProductCategoryResponse[]>(null as any);
    }

    /**
     * (Auth)
     * @param body (optional) 
     * @return Created
     */
    productCategoriesPOST(body: CreateProductCategoryRequest | undefined): Promise<CreateProductCategoryResponse> {
        let url_ = this.baseUrl + "/api/v1/product-categories";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProductCategoriesPOST(_response);
        });
    }

    protected processProductCategoriesPOST(response: Response): Promise<CreateProductCategoryResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = CreateProductCategoryResponse.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CreateProductCategoryResponse>(null as any);
    }

    /**
     * (Auth)
     * @return OK
     */
    productCategoriesGET(id: string): Promise<GetProductCategoryResponse> {
        let url_ = this.baseUrl + "/api/v1/product-categories/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProductCategoriesGET(_response);
        });
    }

    protected processProductCategoriesGET(response: Response): Promise<GetProductCategoryResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetProductCategoryResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GetProductCategoryResponse>(null as any);
    }

    /**
     * (Auth)
     * @param body (optional) 
     * @return OK
     */
    productCategoriesPUT(id: string, body: UpdateProductCategoryRequest | undefined): Promise<UpdateProductCategoryResponse> {
        let url_ = this.baseUrl + "/api/v1/product-categories/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProductCategoriesPUT(_response);
        });
    }

    protected processProductCategoriesPUT(response: Response): Promise<UpdateProductCategoryResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateProductCategoryResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UpdateProductCategoryResponse>(null as any);
    }

    /**
     * (Auth)
     * @return No Content
     */
    productCategoriesDELETE(id: string): Promise<NoContent> {
        let url_ = this.baseUrl + "/api/v1/product-categories/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProductCategoriesDELETE(_response);
        });
    }

    protected processProductCategoriesDELETE(response: Response): Promise<NoContent> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result204 = NoContent.fromJS(resultData204);
            return result204;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NoContent>(null as any);
    }

    /**
     * (Auth)
     * @return OK
     */
    productsAll(): Promise<ListProductResponse[]> {
        let url_ = this.baseUrl + "/api/v1/products";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProductsAll(_response);
        });
    }

    protected processProductsAll(response: Response): Promise<ListProductResponse[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ListProductResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ListProductResponse[]>(null as any);
    }

    /**
     * (Auth)
     * @param body (optional) 
     * @return Created
     */
    productsPOST(body: CreateProductRequest | undefined): Promise<CreateProductResponse> {
        let url_ = this.baseUrl + "/api/v1/products";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProductsPOST(_response);
        });
    }

    protected processProductsPOST(response: Response): Promise<CreateProductResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = CreateProductResponse.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CreateProductResponse>(null as any);
    }

    /**
     * (Auth)
     * @return OK
     */
    productsGET(id: string): Promise<GetProductResponse> {
        let url_ = this.baseUrl + "/api/v1/products/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProductsGET(_response);
        });
    }

    protected processProductsGET(response: Response): Promise<GetProductResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetProductResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GetProductResponse>(null as any);
    }

    /**
     * (Auth)
     * @param body (optional) 
     * @return OK
     */
    productsPUT(id: string, body: UpdateProductRequest | undefined): Promise<UpdateProductResponse> {
        let url_ = this.baseUrl + "/api/v1/products/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProductsPUT(_response);
        });
    }

    protected processProductsPUT(response: Response): Promise<UpdateProductResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateProductResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UpdateProductResponse>(null as any);
    }

    /**
     * (Auth)
     * @return No Content
     */
    productsDELETE(id: string): Promise<NoContent> {
        let url_ = this.baseUrl + "/api/v1/products/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProductsDELETE(_response);
        });
    }

    protected processProductsDELETE(response: Response): Promise<NoContent> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result204 = NoContent.fromJS(resultData204);
            return result204;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NoContent>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    login(body: UserLoginRequest | undefined): Promise<UserLoginResponse> {
        let url_ = this.baseUrl + "/api/v1/users/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: Response): Promise<UserLoginResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserLoginResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserLoginResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    register(body: UserRegisterRequest | undefined): Promise<UserRegisterResponse> {
        let url_ = this.baseUrl + "/api/v1/users/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRegister(_response);
        });
    }

    protected processRegister(response: Response): Promise<UserRegisterResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = UserRegisterResponse.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserRegisterResponse>(null as any);
    }

    /**
     * (Auth)
     * @return OK
     */
    users(id: string): Promise<GetUserResponse> {
        let url_ = this.baseUrl + "/api/v1/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUsers(_response);
        });
    }

    protected processUsers(response: Response): Promise<GetUserResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUserResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GetUserResponse>(null as any);
    }
}

export class CreateProductCategoryRequest implements ICreateProductCategoryRequest {
    name?: string | undefined;
    parentId?: string | undefined;

    constructor(data?: ICreateProductCategoryRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.parentId = _data["parentId"];
        }
    }

    static fromJS(data: any): CreateProductCategoryRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductCategoryRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["parentId"] = this.parentId;
        return data;
    }
}

export interface ICreateProductCategoryRequest {
    name?: string | undefined;
    parentId?: string | undefined;
}

export class CreateProductCategoryResponse implements ICreateProductCategoryResponse {
    id?: string | undefined;
    name?: string | undefined;
    parentId?: string | undefined;

    constructor(data?: ICreateProductCategoryResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.parentId = _data["parentId"];
        }
    }

    static fromJS(data: any): CreateProductCategoryResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductCategoryResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["parentId"] = this.parentId;
        return data;
    }
}

export interface ICreateProductCategoryResponse {
    id?: string | undefined;
    name?: string | undefined;
    parentId?: string | undefined;
}

export class CreateProductRequest implements ICreateProductRequest {
    categoryId?: string | undefined;
    costPrice?: number;
    name?: string | undefined;
    productCd?: string | undefined;
    sellingPrice?: number;
    stock?: number;
    supplierId?: string | undefined;
    txDesc?: string | undefined;
    unit?: string | undefined;
    weight?: number;

    constructor(data?: ICreateProductRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.categoryId = _data["categoryId"];
            this.costPrice = _data["costPrice"];
            this.name = _data["name"];
            this.productCd = _data["productCd"];
            this.sellingPrice = _data["sellingPrice"];
            this.stock = _data["stock"];
            this.supplierId = _data["supplierId"];
            this.txDesc = _data["txDesc"];
            this.unit = _data["unit"];
            this.weight = _data["weight"];
        }
    }

    static fromJS(data: any): CreateProductRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryId"] = this.categoryId;
        data["costPrice"] = this.costPrice;
        data["name"] = this.name;
        data["productCd"] = this.productCd;
        data["sellingPrice"] = this.sellingPrice;
        data["stock"] = this.stock;
        data["supplierId"] = this.supplierId;
        data["txDesc"] = this.txDesc;
        data["unit"] = this.unit;
        data["weight"] = this.weight;
        return data;
    }
}

export interface ICreateProductRequest {
    categoryId?: string | undefined;
    costPrice?: number;
    name?: string | undefined;
    productCd?: string | undefined;
    sellingPrice?: number;
    stock?: number;
    supplierId?: string | undefined;
    txDesc?: string | undefined;
    unit?: string | undefined;
    weight?: number;
}

export class CreateProductResponse implements ICreateProductResponse {
    id?: string | undefined;
    categoryId?: string | undefined;
    costPrice?: number;
    name?: string | undefined;
    productCd?: string | undefined;
    sellingPrice?: number;
    stock?: number;
    supplierId?: string | undefined;
    txDesc?: string | undefined;
    unit?: string | undefined;
    weight?: number;

    constructor(data?: ICreateProductResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.categoryId = _data["categoryId"];
            this.costPrice = _data["costPrice"];
            this.name = _data["name"];
            this.productCd = _data["productCd"];
            this.sellingPrice = _data["sellingPrice"];
            this.stock = _data["stock"];
            this.supplierId = _data["supplierId"];
            this.txDesc = _data["txDesc"];
            this.unit = _data["unit"];
            this.weight = _data["weight"];
        }
    }

    static fromJS(data: any): CreateProductResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["categoryId"] = this.categoryId;
        data["costPrice"] = this.costPrice;
        data["name"] = this.name;
        data["productCd"] = this.productCd;
        data["sellingPrice"] = this.sellingPrice;
        data["stock"] = this.stock;
        data["supplierId"] = this.supplierId;
        data["txDesc"] = this.txDesc;
        data["unit"] = this.unit;
        data["weight"] = this.weight;
        return data;
    }
}

export interface ICreateProductResponse {
    id?: string | undefined;
    categoryId?: string | undefined;
    costPrice?: number;
    name?: string | undefined;
    productCd?: string | undefined;
    sellingPrice?: number;
    stock?: number;
    supplierId?: string | undefined;
    txDesc?: string | undefined;
    unit?: string | undefined;
    weight?: number;
}

export class GetProductCategoryResponse implements IGetProductCategoryResponse {
    id?: string | undefined;
    name?: string | undefined;
    parentId?: string | undefined;

    constructor(data?: IGetProductCategoryResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.parentId = _data["parentId"];
        }
    }

    static fromJS(data: any): GetProductCategoryResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetProductCategoryResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["parentId"] = this.parentId;
        return data;
    }
}

export interface IGetProductCategoryResponse {
    id?: string | undefined;
    name?: string | undefined;
    parentId?: string | undefined;
}

export class GetProductResponse implements IGetProductResponse {
    id?: string | undefined;
    categoryId?: string | undefined;
    costPrice?: number;
    name?: string | undefined;
    productCd?: string | undefined;
    sellingPrice?: number;
    stock?: number;
    supplierId?: string | undefined;
    txDesc?: string | undefined;
    unit?: string | undefined;
    weight?: number;

    constructor(data?: IGetProductResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.categoryId = _data["categoryId"];
            this.costPrice = _data["costPrice"];
            this.name = _data["name"];
            this.productCd = _data["productCd"];
            this.sellingPrice = _data["sellingPrice"];
            this.stock = _data["stock"];
            this.supplierId = _data["supplierId"];
            this.txDesc = _data["txDesc"];
            this.unit = _data["unit"];
            this.weight = _data["weight"];
        }
    }

    static fromJS(data: any): GetProductResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetProductResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["categoryId"] = this.categoryId;
        data["costPrice"] = this.costPrice;
        data["name"] = this.name;
        data["productCd"] = this.productCd;
        data["sellingPrice"] = this.sellingPrice;
        data["stock"] = this.stock;
        data["supplierId"] = this.supplierId;
        data["txDesc"] = this.txDesc;
        data["unit"] = this.unit;
        data["weight"] = this.weight;
        return data;
    }
}

export interface IGetProductResponse {
    id?: string | undefined;
    categoryId?: string | undefined;
    costPrice?: number;
    name?: string | undefined;
    productCd?: string | undefined;
    sellingPrice?: number;
    stock?: number;
    supplierId?: string | undefined;
    txDesc?: string | undefined;
    unit?: string | undefined;
    weight?: number;
}

export class GetUserResponse implements IGetUserResponse {
    id?: string | undefined;
    email?: string | undefined;

    constructor(data?: IGetUserResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): GetUserResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["email"] = this.email;
        return data;
    }
}

export interface IGetUserResponse {
    id?: string | undefined;
    email?: string | undefined;
}

export class ListProductCategoryResponse implements IListProductCategoryResponse {
    id?: string | undefined;
    name?: string | undefined;
    parentId?: string | undefined;

    constructor(data?: IListProductCategoryResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.parentId = _data["parentId"];
        }
    }

    static fromJS(data: any): ListProductCategoryResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ListProductCategoryResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["parentId"] = this.parentId;
        return data;
    }
}

export interface IListProductCategoryResponse {
    id?: string | undefined;
    name?: string | undefined;
    parentId?: string | undefined;
}

export class ListProductResponse implements IListProductResponse {
    id?: string | undefined;
    categoryId?: string | undefined;
    costPrice?: number;
    name?: string | undefined;
    productCd?: string | undefined;
    sellingPrice?: number;
    stock?: number;
    supplierId?: string | undefined;
    txDesc?: string | undefined;
    unit?: string | undefined;
    weight?: number;

    constructor(data?: IListProductResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.categoryId = _data["categoryId"];
            this.costPrice = _data["costPrice"];
            this.name = _data["name"];
            this.productCd = _data["productCd"];
            this.sellingPrice = _data["sellingPrice"];
            this.stock = _data["stock"];
            this.supplierId = _data["supplierId"];
            this.txDesc = _data["txDesc"];
            this.unit = _data["unit"];
            this.weight = _data["weight"];
        }
    }

    static fromJS(data: any): ListProductResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ListProductResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["categoryId"] = this.categoryId;
        data["costPrice"] = this.costPrice;
        data["name"] = this.name;
        data["productCd"] = this.productCd;
        data["sellingPrice"] = this.sellingPrice;
        data["stock"] = this.stock;
        data["supplierId"] = this.supplierId;
        data["txDesc"] = this.txDesc;
        data["unit"] = this.unit;
        data["weight"] = this.weight;
        return data;
    }
}

export interface IListProductResponse {
    id?: string | undefined;
    categoryId?: string | undefined;
    costPrice?: number;
    name?: string | undefined;
    productCd?: string | undefined;
    sellingPrice?: number;
    stock?: number;
    supplierId?: string | undefined;
    txDesc?: string | undefined;
    unit?: string | undefined;
    weight?: number;
}

export class NoContent implements INoContent {
    readonly statusCode?: number;

    constructor(data?: INoContent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).statusCode = _data["statusCode"];
        }
    }

    static fromJS(data: any): NoContent {
        data = typeof data === 'object' ? data : {};
        let result = new NoContent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        return data;
    }
}

export interface INoContent {
    statusCode?: number;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

export class UpdateProductCategoryRequest implements IUpdateProductCategoryRequest {
    name?: string | undefined;
    parentId?: string | undefined;

    constructor(data?: IUpdateProductCategoryRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.parentId = _data["parentId"];
        }
    }

    static fromJS(data: any): UpdateProductCategoryRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductCategoryRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["parentId"] = this.parentId;
        return data;
    }
}

export interface IUpdateProductCategoryRequest {
    name?: string | undefined;
    parentId?: string | undefined;
}

export class UpdateProductCategoryResponse implements IUpdateProductCategoryResponse {
    id?: string | undefined;
    name?: string | undefined;
    parentId?: string | undefined;

    constructor(data?: IUpdateProductCategoryResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.parentId = _data["parentId"];
        }
    }

    static fromJS(data: any): UpdateProductCategoryResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductCategoryResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["parentId"] = this.parentId;
        return data;
    }
}

export interface IUpdateProductCategoryResponse {
    id?: string | undefined;
    name?: string | undefined;
    parentId?: string | undefined;
}

export class UpdateProductRequest implements IUpdateProductRequest {
    categoryId?: string | undefined;
    costPrice?: number;
    name?: string | undefined;
    productCd?: string | undefined;
    sellingPrice?: number;
    stock?: number;
    supplierId?: string | undefined;
    txDesc?: string | undefined;
    unit?: string | undefined;
    weight?: number;

    constructor(data?: IUpdateProductRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.categoryId = _data["categoryId"];
            this.costPrice = _data["costPrice"];
            this.name = _data["name"];
            this.productCd = _data["productCd"];
            this.sellingPrice = _data["sellingPrice"];
            this.stock = _data["stock"];
            this.supplierId = _data["supplierId"];
            this.txDesc = _data["txDesc"];
            this.unit = _data["unit"];
            this.weight = _data["weight"];
        }
    }

    static fromJS(data: any): UpdateProductRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryId"] = this.categoryId;
        data["costPrice"] = this.costPrice;
        data["name"] = this.name;
        data["productCd"] = this.productCd;
        data["sellingPrice"] = this.sellingPrice;
        data["stock"] = this.stock;
        data["supplierId"] = this.supplierId;
        data["txDesc"] = this.txDesc;
        data["unit"] = this.unit;
        data["weight"] = this.weight;
        return data;
    }
}

export interface IUpdateProductRequest {
    categoryId?: string | undefined;
    costPrice?: number;
    name?: string | undefined;
    productCd?: string | undefined;
    sellingPrice?: number;
    stock?: number;
    supplierId?: string | undefined;
    txDesc?: string | undefined;
    unit?: string | undefined;
    weight?: number;
}

export class UpdateProductResponse implements IUpdateProductResponse {
    id?: string | undefined;
    categoryId?: string | undefined;
    costPrice?: number;
    name?: string | undefined;
    productCd?: string | undefined;
    sellingPrice?: number;
    stock?: number;
    supplierId?: string | undefined;
    txDesc?: string | undefined;
    unit?: string | undefined;
    weight?: number;

    constructor(data?: IUpdateProductResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.categoryId = _data["categoryId"];
            this.costPrice = _data["costPrice"];
            this.name = _data["name"];
            this.productCd = _data["productCd"];
            this.sellingPrice = _data["sellingPrice"];
            this.stock = _data["stock"];
            this.supplierId = _data["supplierId"];
            this.txDesc = _data["txDesc"];
            this.unit = _data["unit"];
            this.weight = _data["weight"];
        }
    }

    static fromJS(data: any): UpdateProductResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["categoryId"] = this.categoryId;
        data["costPrice"] = this.costPrice;
        data["name"] = this.name;
        data["productCd"] = this.productCd;
        data["sellingPrice"] = this.sellingPrice;
        data["stock"] = this.stock;
        data["supplierId"] = this.supplierId;
        data["txDesc"] = this.txDesc;
        data["unit"] = this.unit;
        data["weight"] = this.weight;
        return data;
    }
}

export interface IUpdateProductResponse {
    id?: string | undefined;
    categoryId?: string | undefined;
    costPrice?: number;
    name?: string | undefined;
    productCd?: string | undefined;
    sellingPrice?: number;
    stock?: number;
    supplierId?: string | undefined;
    txDesc?: string | undefined;
    unit?: string | undefined;
    weight?: number;
}

export class UserLoginRequest implements IUserLoginRequest {
    username!: string;
    password!: string;

    constructor(data?: IUserLoginRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): UserLoginRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["password"] = this.password;
        return data;
    }
}

export interface IUserLoginRequest {
    username: string;
    password: string;
}

export class UserLoginResponse implements IUserLoginResponse {
    id?: string | undefined;
    accessToken?: string | undefined;

    constructor(data?: IUserLoginResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.accessToken = _data["accessToken"];
        }
    }

    static fromJS(data: any): UserLoginResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["accessToken"] = this.accessToken;
        return data;
    }
}

export interface IUserLoginResponse {
    id?: string | undefined;
    accessToken?: string | undefined;
}

export class UserRegisterRequest implements IUserRegisterRequest {
    email?: string | undefined;
    password?: string | undefined;
    confirmPassword?: string | undefined;

    constructor(data?: IUserRegisterRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
            this.confirmPassword = _data["confirmPassword"];
        }
    }

    static fromJS(data: any): UserRegisterRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UserRegisterRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        data["confirmPassword"] = this.confirmPassword;
        return data;
    }
}

export interface IUserRegisterRequest {
    email?: string | undefined;
    password?: string | undefined;
    confirmPassword?: string | undefined;
}

export class UserRegisterResponse implements IUserRegisterResponse {
    id?: string | undefined;
    accessToken?: string | undefined;

    constructor(data?: IUserRegisterResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.accessToken = _data["accessToken"];
        }
    }

    static fromJS(data: any): UserRegisterResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UserRegisterResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["accessToken"] = this.accessToken;
        return data;
    }
}

export interface IUserRegisterResponse {
    id?: string | undefined;
    accessToken?: string | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}